# Rust gRPC implementation

## Table of Contents

- [Motivation](#motivation)
- [Directory Structure](#directory-structure)
- [Start Project](#start-project)
- [Architecture](#architecture)
   - [Proto](#proto)
   - [build.rs](#buildrs)

---
## Motivation

I would like to understand how Rust works with gRPC. 

We will create 

- greeting server
- greeting client

and let client communicate to server via gRPC. 

---
## Directory Structure


```sh 
$ tree . -L 3
.
├── Cargo.lock
├── Cargo.toml
├── LICENSE
├── README
├── README.md
├── RUST_GRPC
├── grpc-client
│   ├── Cargo.toml
│   └── src
│       └── main.rs
├── grpc-server
│   ├── Cargo.toml
│   └── src
│       └── main.rs
├── proto
│   └── hello.proto
├── proto-defs
│   ├── Cargo.toml
│   ├── build.rs
│   └── src
│       ├── generated
│       └── lib.rs
...
```


---
## Start Project 

We will use cargo to create a rust project. We need 4 directories. 

1. grcp-client
2. grcp-server
3. proto
4. prroto-defs


It sounds redundant, and may be wrong, but we need ```Cargo.toml``` in 

- grpc-client
- grpc-server
- proto-defs

in addition to the project root. So, create projects for each. 

First at the project root
```sh 
$ touch Cargo.toml
```

Then, create each package, 
```sh 
$ cargo new grpc-server 
$ cargo new grpc-client
$ cargo new proto-defs
```

```cargo new ... ``` creates a new directory
of the given name, and Cargo.toml in each of them. 

However, the last 3 of them, only point
to (linked to) Cargo.toml at the project root. 

The one at project root looks like this.

```sh
$ cat Cargo.toml
[workspace]
members = [
    "proto-defs",
    "grpc-server",
    "grpc-client"
]
resolver = "3"

[workspace.dependencies]
tonic = "0.14"
tonic-prost = "0.14"
prost = "0.14"
# prost-derive = "0.14"
tokio = { version = "1.48.0", features = ["macros", "rt-multi-thread"]}
proto-defs = {path = "./proto-defs"}

```

while all the others are identical, 
only differs at package.name, which points
to the package name itself, and 
```proto-defs```, where proto-defs itself 
does not require to point itself. 

```sh
$ cat */Cargo.toml
[package]
name = "grpc-client"
version = "0.1.0"
edition = "2024"

[dependencies]
proto-defs = { path= "../proto-defs" }
tonic.workspace = true
tonic-prost.workspace = true
prost.workspace = true
tokio.workspace = true
#A prost-derive.workspace = true

```

## Architecture

### Proto

We will go back a bit and look at the architecture. 

One impressive stuff in the combination of Rust + 
gRPC is the function of ```proto```. 


proto only has one file in the directory.

```sh
$ cat proto/hello.proto
syntax = "proto3";

package hello;

service Greeter {
    rpc SayHello (HelloRequest) returns (HelloReply);
}

message HelloRequest{
    string name = 1;
}

message HelloReply{
    string message = 1;
}
```

The first entry ```service Greeter``` defines what this gRPC service does, namely, it receives ```HelloRequest``` and returns ```HelloReply```. 

The second and the third entries define what ```HelloRequest``` and ```HelloReply```, namely, they have one string, 'name' in ```HelloRequest``` messageand 'meesage' in ```HelloReply```. 　The name of API method is ```SayHello```.


**AND** this short script create whole server and client
plus Rust structures in a new code ```hello.rs```. 

Let us look at a part of ```hello.rs``` (built beforehand. 
We will discuss how to build it later). 

```sh

$ find . | grep hello.rs
./target/debug/build/proto-defs-c9c645741b3a0923/out/hello.rs


$ head ./target/debug/build/proto-defs-c9c645741b3a0923/out/hello.rs | cat
// This file is @generated by prost-build.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HelloRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HelloReply {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,

```

Here Rust structures are defined in the syntax of Rust. 

```sh

$ grep mod -A10 ./target/debug/build/proto-defs-c9c645741b3a0923/out/hello.rs | cat
pub mod greeter_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
--
pub mod greeter_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with GreeterServer.
    #[async_trait]
```

Here two Rust modules, greeter_client and greeter_servers are defined. 
```sh
$ grep -i sayhello  -A5 ./target/debug/build/proto-defs-c9c645741b3a0923/out/hello.rs | cat
...
/// Generated server implementations.
--
                "/hello.Greeter/SayHello" => {
                    #[allow(non_camel_case_types)]
                    struct SayHelloSvc<T: Greeter>(pub Arc<T>);
                    impl<T: Greeter> tonic::server::UnaryService<super::HelloRequest>
                    for SayHelloSvc<T> {
                        type Response = super::HelloReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;

...
```

Here teh API method (= endpoint) is defined. 

```sh

$ wc ./target/debug/build/proto-defs-c9c645741b3a0923/out/hello.rs
     299     843   11859 ./target/debug/build/proto-defs-c9c645741b3a0923/out/hello.rs

```     
```hello.rs``` code is about 300 line long, and this is crated automatically by 
just declaratively writing ./proto/hello.proto. Wunderbar. 

---
### ```build.rs```

AWhen we execute 






---
# END
---
cargo new proto-defs --lib

